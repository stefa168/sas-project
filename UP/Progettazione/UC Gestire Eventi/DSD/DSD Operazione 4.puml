@startuml
skinparam Style strictuml

collections UI
participant "eventManager: EventManager" as em
participant "eventToEdit: Event" as ev
participant "userMgr: UserManager" as um
participant "eventManager.eventReceivers: EventEventReceivers" as eer
participant "eventToEdit.macroEvent: MacroEvent" as maev
participant "event: Event" as event_iterator
participant "frequency: Frequency" as freq
participant "addedEvents: ArrayList<Event>" as addedEvents
participant "removedEvents: ArrayList<Event>" as removedEvents
participant "newEvent: Event" as newEvent
participant "newService: Service" as newService

UI -> em: editEventDetails(eventToEdit, frequency?, startDate?)

activate em
    em -> um: getCurrentUser()
    activate um
        em <<-- um: user
    deactivate um

    alt !user.isOrganizer() || eventToEdit.getMacroEvent().getOrganizer() != user ||\n || (startDate != null && startDate.compareTo(LocalDate.now()) < 0) ||\n !(eventToEdit.state.equals("programmed") || eventToEdit.state.equals("compiled") || eventToEdit.state.equals("active"))
        UI <<-- em: throw UseCaseLogicException
    else
        alt startDate != null
            em -> ev: editDetails(startDate)
            activate ev
            ev -> ev: this.dateStart = startDate
            alt this.state.equals("programmed")
                ev -> ev: this.state = "compiled"
            end
            return eventToEdit

            em -> em: notifyEditEvent(eventToEdit)
            activate em
                loop for all receivers in eventReceivers
                    em -> eer: updateEditEvent(event)
                    activate eer
                    deactivate eer
                end
            deactivate em
            |||
        end

        alt frequency != null
            em -> maev: changeFrequency(frequency)
            activate maev
                maev -->> removedEvents**: create()
                activate removedEvents
                return removedEvents

                loop for all event in macroEvent.events
                    alt event.state.equals("programmed")
                        maev -> event_iterator: delete()
                        note right: La definizione completa di //delete()// è\nnel DSD 1a.2b.1 dell'UC Gestire Eventi
                        activate event_iterator
                        deactivate event_iterator
                        maev -> removedEvents: add(event)
                        activate removedEvents
                        deactivate removedEvents
                    end
                end

                maev -> maev: this.frequency = frequency

                maev -> freq: getDates()
                note right: //getDates()// genera una lista con tutte\nle date delle occorrenze dell'evento\nche devono ancora tenersi
                activate freq
                return frequencies

                maev -->> addedEvents**: create()
                activate addedEvents
                return addedEvents

                loop for all date in frequencies
                    maev -> maev: addEvent(date)
                    note right: La definizione completa di //addEvent()// è\nnel DSD 1 dell'UC Gestire Eventi
                    activate maev
                        maev -[hidden]> newEvent **
                    return newEvent

                    maev -> maev: this.events.add(newEvent)

                    maev -> addedEvents: add(newEvent)
                    activate addedEvents
                    deactivate addedEvents

                    loop for all service in macroEvent.defaultEvent.services
                        maev -> newEvent: cloneService(service)

                        activate newEvent
                            newEvent -> newEvent: addService(service.offsetDay, service.startHour, service.endHour,\n\t\t service.diners, service.place, service.typology)
                            note right: La definizione completa di //addService()// è\nnel DSD 5 dell'UC Gestire Eventi
                            activate newEvent
                                newEvent -[hidden]> newService **
                            return newService

                            newEvent -> newEvent: this.services.add(newService)

                            newEvent -> newService : clonePatches(service)
                            activate newService
                                loop for all patch in service.patches
                                    newService -> newService: patches.add(patch.clone())
                                end
                            deactivate newService

                            newEvent -> newService: assignChef(service.assignedChef)
                            activate newService
                                newService -> newService: this.assignedChef = chef
                                newEvent <[hidden]- newService
                            deactivate newService
                        deactivate newEvent
                    end
                end

            return addedEvents, removedEvents

            loop for all addedEvent in addedEvents
                em -> em: notifyCreateEvent(addedEvent)
                activate em
                    loop for all receivers in eventReceivers
                        em -> eer: updateCreateEvent(addedEvent)
                        activate eer
                        deactivate eer
                    end
                deactivate em
            end
            loop for all removedEvent in removedEvents
                em -> em: notifyRemoveEvent(removedEvent)
                activate em
                    loop for all receivers in eventReceivers
                        em -> eer: updateCreateEvent(removedEvent)
                        activate eer
                        deactivate eer
                    end
                deactivate em
            end
        end
    end
deactivate em
@enduml