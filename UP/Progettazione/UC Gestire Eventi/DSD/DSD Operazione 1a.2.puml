@startuml
skinparam Style strictuml

collections UI
participant "evenManager: EventManager" as em
participant "userMgr: UserManager" as um
participant "macroEvent: MacroEvent" as maev
participant "event: Event" as event
participant "task: Task" as task
participant "service.serviceJobs: ArrayList<ServiceJob>" as sj
participant "ev: Event" as ev
participant "cancelEvents: ArrayList <Event>" as evcanc
participant "eventManager.eventReceivers: EventEventReceivers" as eer

UI -> em: cancelEvent(event, strategy)
activate em
    em -> um: getCurrentUser()
    activate um
        em <<-- um: user
    deactivate um

    alt !user.isOrganizer() || event.getMacroEvent().getOrganizer() != user || !(event.state.equals("active")
        UI <<-- em: throw UseCaseLogicException
    else

        em -> maev: cancel(event, strategy)
        activate maev
            maev -->> evcanc**: create()
            activate evcanc
            maev <<-- evcanc: cancelEvents
            deactivate evcanc

            maev -> event: cancel()
            activate event
            event -> event: this.state = cancel

            loop for all service in event.services
                loop for all task in service.sheet.tasks
                    event -> task: deleteAllKitchenJobs()
                    activate task
                    loop for all job in task.jobs
                        task -> task: this.deleteKitchenJob(job)
                        note right: La definizione completa di\n//deleteKitchenJob(job)// Ã¨ nel DSD 6a \ndell' UC Gestire Compiti Cucina
                    end
                    event <<-- task: task
                    deactivate task

                end

                event -> sj: clear ()
                activate sj
                deactivate sj
            end
            maev <<-- event: event
            deactivate event
            maev -> evcanc: add(event)
            activate evcanc
            deactivate evcanc
            |||
            alt strategy.equals("All")
                loop for all ev in macroEvent.events && !ev.equals(event) && (event.state.equals("active")
                    maev -> ev: cancel()
                    note right: La definizione di //cancel()// usata qua e sotto \nfa riferimento a quella sopra definita
                    activate ev
                    maev <<-- ev: ev
                    deactivate ev
                    maev -> evcanc: add(ev)
                    activate evcanc
                    deactivate evcanc
                end
            else strategy.equals ("AllNext")
                loop for all ev in macroEvent.events && !ev.equals(event) && ev.getStartDate().compareTo(event.getStartDate()) > 0 && (event.state.equals("active")
                    maev -> ev: cancel()
                    activate ev
                    maev <<-- ev: ev
                    deactivate ev
                    maev -> evcanc: add(ev)
                    activate evcanc
                    deactivate evcanc
                end
            end
        em <<-- maev: cancelEvents
        deactivate maev
        |||
        em -> em: notifyCancelEvent(event)
        activate em
            loop for all event in cancelEvents
                loop for all receivers in eventReceivers
                    em -> eer: updateCancelEvent(event)
                    activate eer
                    deactivate eer
                end
            end
        deactivate em
        |||

    end
deactivate em
@enduml